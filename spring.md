[Вопросы для собеседования](README.md)

# Spring
+ [Что такое Spring?](#Что-такое-Spring)
+ [IoC(Inversion of Control), DI(Dependency Injection), ApplicationContext](#IoC-DI-ApplicationContext) 
+ [Что такое Spring Beans](#что-такое-spring-beans)
+ [В чём разница между `@Component`, `@Service` и `@Repository` аннотациями?](#в-чём-разница-между-component-service-и-repository-аннотациями)
+ [Какие bean scopes вы знаете?](#какие-bean-scopes-вы-знаете)
+ [Spring Data](#spring-data)
+ [Spring Security](#spring-security)
+ [Spring Boot](#spring-boot)
## Что такое Spring?

__Spring Framework (или коротко Spring)__ - универсальный фреймворк с открытым исходным кодом для Java-платформы. Центральной частью Spring является контейнер Inversion of Control, который предоставляет средства конфигурирования и управления объектами Java. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.

Spring имеет множество дочерних под проектов, в том числе:

+ _Data_ - для работы с хранилищами данных.
+ _MVC_ - для создания веб приложений.
+ _Boot_ - для быстрой компоновки и создания приложения на основе других Spring проектов.
+ _Cloud_ - для создания распределённой приложений.

[к оглавлению](#spring)

## IoC, DI, ApplicationContext

__IoC__ (Inversion of Control) и __DI__ (Dependency Injection) - это понятия, связанные с организацией кода в приложении и управлением зависимостями между классами.

__IoC__ - это шаблон проектирования, который переносит ответственность за создание и управление объектами из вызывающего кода в среду исполнения. При использовании IoC контейнер управляет жизненным циклом объектов и определяет, какие классы должны быть созданы и когда. Таким образом, IoC отделяет создание объектов от их использования.

__DI__ - это конкретная реализация принципа IoC, которая использует механизмы, такие как конструкторы или методы, для внедрения зависимостей в объекты. Это означает, что зависимости передаются в виде параметров в конструктор или метод объекта, вместо того чтобы объект сам создавал эти зависимости. Таким образом, DI позволяет избавиться от жестких зависимостей между классами и сделать код более гибким и модульным.

__ApplicationContext__ - это реализация IoC в Spring. ApplicationContext хранит все компоненты, созданные приложением. Он отвечает за создание экземпляров, настройку и создание компонентов.

[к оглавлению](#spring)

## Что такое Spring Beans

Spring Beans — это просто объекты, которые формируются и управляются Spring IoC (Inversion of Control) контейнером. В контексте Spring, Bean — это объект, который подготовлен для использования и можно получить на запрос. По сути, это объекты, которые заполняются и конфигурируются контейнером Spring.

[к оглавлению](#spring)

## В чём разница между `@Component`, `@Service` и `@Repository` аннотациями?

Все они определяют бины Spring. Однако между ними всё же есть разница.

`@Component` — универсальный компонент
`@Repository` — компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.
`@Service` — фасад для некоторой бизнес логики

Пользовательские аннотации, производные от @Component, могут добавлять специальную логику в бинах.
Например, бины, получившиеся при помощи @Repository, дополнительно имеют обработку для JDBC Exception

[к оглавлению](#spring)

## Какие bean scopes вы знаете?

В Spring Framework существуют следующие виды bean scope:

+ __Singleton__: Это наиболее распространенный и используемый по умолчанию scope. При использовании singleton scope, Spring контейнер создает только один экземпляр бина и делит его между всеми запросами. Это означает, что все компоненты, которые зависят от этого бина, будут использовать один и тот же экземпляр.
+ __Prototype__: При использовании prototype scope, Spring контейнер создает новый экземпляр бина каждый раз, когда он запрашивается. Это означает, что каждый компонент, который зависит от этого бина, будет использовать свой собственный экземпляр.
+ __Request__: Этот scope связан с жизненным циклом HTTP запроса. При использовании request scope, Spring контейнер создает новый экземпляр бина для каждого HTTP запроса и уничтожает его по завершении запроса.
+ __Session__: Этот scope связан с жизненным циклом HTTP сессии. При использовании session scope, Spring контейнер создает новый экземпляр бина для каждой HTTP сессии и уничтожает его по завершении сессии.
+ __Application__: Этот scope связан с жизненным циклом веб-приложения. При использовании application scope, Spring контейнер создает только один экземпляр бина для всего веб-приложения и делит его между всеми запросами.
+ __WebSocket__: Этот scope связан с жизненным циклом WebSocket соединения. При использовании websocket scope, Spring контейнер создает новый экземпляр бина для каждого WebSocket соединения и уничтожает его по завершении соединения.

[к оглавлению](#spring)

## Spring Data

__Spring Data__ — подпроект Spring для взаимодействия с сущностями базы данных, организации их в репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без имплементации.

Основное понятие в Spring Data — это репозиторий. Наиболее часто используемый - интерфейс CrudRepository обеспечивает основные операции по поиску, сохранения, удалению данных (CRUD операции).

Т.е. если того перечня что предоставляет интерфейс достаточно для взаимодействия с сущностью, то можно прямо расширить базовый интерфейс для своей сущности, дополнить его своими методами запросов и выполнять операции.

Понятно что этого перечня, скорее всего не хватит для взаимодействия с сущностью, и тут можно расширить свой интерфейс дополнительными методами запросов. Запросы к сущности можно строить прямо из имени метода. Для этого используется механизм префиксов find…By, read…By, query…By, count…By, и get…By, далее от префикса метода начинает разбор остальной части. Вводное предложение может содержать дополнительные выражения, например, Distinct. Далее первый By действует как разделитель, чтобы указать начало фактических критериев. Можно определить условия для свойств сущностей и объединить их с помощью And и Or.

Если нужен специфичный метод или его реализация, которую нельзя описать через имя метода, то это можно сделать через некоторый Customized интерфейс ( CustomizedEmployees) и сделать реализацию вычисления. А можно пойти другим путем, через указание запроса (HQL или SQL), как вычислить данную функцию. Отметив запрос аннотацией @Query.

[к оглавлению](#spring)

## Spring Security

__Spring Security__ предоставляет широкие возможности для защиты приложения. Кроме стандартных настроек для аутентификации, авторизации и распределения ролей и маппинга доступных страниц, ссылок и т.п., предоставляет защиту от различных вариантов атак

__Spring Security__ - это список фильтров в виде класса FilterChainProxy, интегрированного в контейнер сервлетов, и в котором есть поле List. Каждый фильтр реализует какой-то механизм безопасности. Важна последовательность фильтров в цепочке.

[к оглавлению](#spring)

## Spring Boot

По сути, Spring Boot это просто набор классов конфигурации, которые создают нужные бины в контексте. Точно так же их можно создать руками, просто Boot это автоматизирует. При этом помогая решить проблему конфликтов разных версий компонентов.

Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)

Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволит получить универсальное решение для всех, связанных со Spring технологий, избавляя программиста от лишнего поиска примеров кода и загрузки из них требуемых дескрипторов зависимостей. Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa и все будет готово (вам не придется искать совместимые драйверы баз данных и библиотеки Hibernate)

Например, если вы добавите Spring-boot-starter-web, Spring Boot автоматически сконфигурирует такие зарегистрированные бины, как DispatcherServlet, ResourceHandlers, MessageSource. Если вы используете spring-boot-starter-jdbc, Spring Boot автоматически регистрирует бины DataSource, EntityManagerFactory, TransactionManager и считывает информацию для подключения к базе данных из файла application.properties

В основе "магии" Spring Boot нет ничего магического, он использует совершенно базовые понятия из Spring Framework. В кратком виде процесс можно описать так:

+ Аннотация @SpringBootApplication включает сканирование компонентов и авто-конфигурацию через аннотацию @EnableAutoConfiguration
+ @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector
+ EnableAutoConfigurationImportSelector загружает список конфигураций из файла META-INF/spring.factories
+ Каждая конфигурация пытается сконфигурить различные аспекты приложения (web, JPA, AMQP etc), регистрируя нужные бины и используя различные условия (наличие / отсутствие бина, настройки, класса и т.п.)
+ Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container
+ Servlet container запускается, приложение готово к работе!
Важное понятие Spring Boot это автоконфигурация. По сути, это просто набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении. По большому счету, даже сам Embedded Servlet Container — это просто еще один бин, который можно сконфигурировать! Пара важных моментов, которые важно знать об автоконфигурации:

Отключить ненужные автоконфигурации можно при помощи свойств exclude и excludeName аннотаций @EnableAutoConfiguration, @ImportAutoConfiguration и @SpringBootApplication. Или в property задать SpringAutoconfiguration exclude и передать имена классов.

Можно отказаться от использования механизма автоконфигурации, вместо этого указывая необходимые автоконфигурации вручную. Для этого надо избавиться от аннотаций @SpringBootApplication и @EnableAutoConfiguration в коде вашего проекта, а для указания нужных конфигурационных классов использовать аннотации @SpringBootConfiguration и @ImportAutoConfiguration. Однако стоит помнить, что используемые автоконфигурации всё ещё могут содержать неиспользуемые компоненты.

[к оглавлению](#spring)



## В 



[к оглавлению](#spring)

[Вопросы для собеседования](README.md)
